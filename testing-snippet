import os
import javalang
from collections import defaultdict

# --- Configuration ---
# TODO: Set the path to the folder containing your Java stub classes.
STUBS_DIRECTORY = './stubs'  # <-- IMPORTANT: CHANGE THIS PATH
# TODO: Set the name of the root class from which to start parsing.
ROOT_CLASS_NAME = 'RootObject'  # <-- IMPORTANT: CHANGE THIS
# The variable name to use for the root object in the generated chains.
ROOT_OBJECT_VARIABLE = 'rootObject'
# NEW: Set a max depth to prevent hanging on very complex object graphs.
# You can increase this if you need deeper chains.
MAX_DEPTH = 15

# A set of types that should be considered "terminal". 
# The script will not try to find getters in these. 
# Enums found during parsing will be added to this set automatically.
TERMINAL_TYPES = {
    'String', 'int', 'Integer', 'long', 'Long', 'double', 'Double',
    'boolean', 'Boolean', 'BigDecimal', 'XMLGregorianCalendar', 'Object'
}

class FieldInfo:
    """A simple class to hold information about a class field."""
    def __init__(self, name, type_name, is_list=False):
        self.name = name
        self.type_name = type_name
        self.is_list = is_list

    def __repr__(self):
        list_str = "List of " if self.is_list else ""
        return f"Field(name={self.name}, type={list_str}{self.type_name})"

def parse_java_files(directory):
    """
    Parses all .java files in a directory and builds a map of classes and their fields.

    Args:
        directory (str): The path to the directory containing .java files.

    Returns:
        A tuple containing:
        - dict: A dictionary mapping class names to a list of FieldInfo objects.
        - set: A set of all enum names found.
    """
    class_map = defaultdict(list)
    enum_names = set()
    if not os.path.isdir(directory):
        print(f"Error: Directory not found at '{directory}'")
        return class_map, enum_names

    print(f"Scanning for .java files in '{directory}'...")
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.java'):
                filepath = os.path.join(root, file)
                print(f"  Parsing: {filepath}")
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    try:
                        content = f.read()
                        tree = javalang.parse.parse(content)
                        
                        # javalang's filter is recursive, finding all type declarations
                        # including inner/nested classes.
                        for _, node in tree.filter(javalang.tree.TypeDeclaration):
                            type_name = node.name

                            if isinstance(node, javalang.tree.EnumDeclaration):
                                enum_names.add(type_name)
                                continue

                            # Process fields for classes and interfaces
                            if isinstance(node, (javalang.tree.ClassDeclaration, javalang.tree.InterfaceDeclaration)):
                                for field_declaration in node.fields:
                                    field_type_node = field_declaration.type
                                    field_type_name = field_type_node.name
                                    is_list = field_type_name == 'List'

                                    # If it's a generic type like List<SomeType>, extract 'SomeType'
                                    if is_list and field_type_node.arguments:
                                        type_arg = field_type_node.arguments[0].type
                                        if type_arg:
                                            field_type_name = type_arg.name

                                    for declarator in field_declaration.declarators:
                                        field_name = declarator.name
                                        class_map[type_name].append(
                                            FieldInfo(field_name, field_type_name, is_list)
                                        )
                    except (javalang.tokenizer.LexerError, javalang.parser.JavaSyntaxError) as e:
                        print(f"    - FAILED to parse {file}. It likely has a syntax error.")
                        print(f"    - Error details: {e}")
                    except Exception as e:
                        print(f"    - An unexpected error occurred with file {filepath}: {e}")
                        
    print("\nFinished parsing.")
    print("-" * 30)
    print("Found definitions for the following classes/interfaces:")
    for cls_name in sorted(class_map.keys()):
        print(f"- {cls_name}")
    print("\nFound definitions for the following enums (treated as terminal types):")
    for enum_name in sorted(enum_names):
        print(f"- {enum_name}")
    print("-" * 30)
    return class_map, enum_names

def generate_getter_chains(root_class, class_map):
    """
    Generates all possible getter chains starting from a root class.

    Args:
        root_class (str): The name of the starting class.
        class_map (dict): The map of classes and their fields.

    Returns:
        list: A list of strings, where each string is a complete getter chain.
    """
    all_chains = []

    # A recursive DFS function to explore the class graph
    def find_paths(class_name, current_chain, visited_path, depth):
        # Stop recursion if we hit the max depth to prevent hanging
        if depth >= MAX_DEPTH:
            all_chains.append(f"{current_chain}.<... max depth reached ...>")
            return
            
        # Cycle detection: if we've seen this class in this specific path, stop.
        if class_name in visited_path:
            return

        visited_path.add(class_name)
        fields = class_map.get(class_name, [])

        for field in fields:
            # Construct the getter method name, e.g., 'name' -> 'getName'
            getter_name = f"get{field.name[0].upper()}{field.name[1:]}"
            
            # Append the getter call. If it's a list, add a placeholder.
            list_accessor = ".get(i)" if field.is_list else ""
            new_chain = f"{current_chain}..{getter_name}(){list_accessor}"

            # If the field's type is terminal, this path ends.
            if field.type_name in TERMINAL_TYPES:
                all_chains.append(new_chain)
            # If it's another custom class, recurse.
            elif field.type_name in class_map:
                find_paths(field.type_name, new_chain, visited_path.copy(), depth + 1)
            # Otherwise, it's an unknown type, treat it as a terminal path.
            else:
                all_chains.append(new_chain)

    print(f"\nGenerating getter chains starting from root: '{root_class}' (max depth: {MAX_DEPTH})\n")
    if root_class not in class_map:
        print(f"Error: Root class '{root_class}' not found in parsed files.")
        return []
        
    # Start the recursion with initial depth 0
    find_paths(root_class, ROOT_OBJECT_VARIABLE, set(), 0)
    return all_chains

def main():
    """Main function to run the script."""
    # 1. Parse all java files to understand the structure
    class_map, found_enums = parse_java_files(STUBS_DIRECTORY)
    
    # Add any discovered enums to the set of types that stop the chain.
    TERMINAL_TYPES.update(found_enums)

    if not class_map:
        print("\nNo classes were parsed. Please check the STUBS_DIRECTORY path and ensure the Java files are syntactically correct.")
        return

    # 2. Generate the getter chains from the root class
    getter_chains = generate_getter_chains(ROOT_CLASS_NAME, class_map)

    # 3. Print the results
    if getter_chains:
        print("--- Found Getter Chains ---")
        for chain in sorted(getter_chains):
            print(chain)
        print(f"\nTotal chains found: {len(getter_chains)}")
    else:
        print("No getter chains could be generated. Check your ROOT_CLASS_NAME and make sure the root class and its dependencies were parsed correctly.")

if __name__ == '__main__':
    # Before running, make sure you have javalang installed:
    # pip install javalang
    main()
